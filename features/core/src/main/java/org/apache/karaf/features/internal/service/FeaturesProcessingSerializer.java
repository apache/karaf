/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.karaf.features.internal.service;

import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.stream.XMLEventFactory;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLEventWriter;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.events.XMLEvent;
import javax.xml.transform.stream.StreamResult;

import org.apache.karaf.features.internal.model.processing.FeaturesProcessing;
import org.apache.karaf.features.internal.model.processing.ObjectFactory;
import org.apache.karaf.util.xml.IndentingXMLEventWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A class to help serialize {@link org.apache.karaf.features.internal.model.processing.FeaturesProcessing} model
 * but with added template comments for main sections of <code>org.apache.karaf.features.xml</code> file.
 */
public class FeaturesProcessingSerializer {

    public static Logger LOG = LoggerFactory.getLogger(FeaturesProcessingSerializer.class);

    private JAXBContext FEATURES_PROCESSING_CONTEXT;

    public FeaturesProcessingSerializer() {
        try {
            FEATURES_PROCESSING_CONTEXT = JAXBContext.newInstance(ObjectFactory.class);
        } catch (JAXBException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Reads {@link FeaturesProcessing features processing model} from input stream
     * @param stream
     * @return
     */
    public FeaturesProcessing read(InputStream stream) throws JAXBException {
        Unmarshaller unmarshaller = FEATURES_PROCESSING_CONTEXT.createUnmarshaller();
        return (FeaturesProcessing) unmarshaller.unmarshal(stream);
    }

    /**
     * Writes the model to output stream and adds comments for main sections.
     * @param model
     * @param output
     */
    public void write(FeaturesProcessing model, OutputStream output) {
        try {
            // JAXB model as stream which is next parsed as XMLEvents
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            Marshaller marshaller = FEATURES_PROCESSING_CONTEXT.createMarshaller();
            marshaller.marshal(model, new StreamResult(baos));

            Map<String, Boolean> emptyElements = new HashMap<>();
            emptyElements.put("blacklistedRepositories", model.getBlacklistedRepositories().size() == 0);
            emptyElements.put("blacklistedFeatures", model.getBlacklistedFeatures().size() == 0);
            emptyElements.put("blacklistedBundles", model.getBlacklistedBundles().size() == 0);
            emptyElements.put("overrideBundleDependency", model.getOverrideBundleDependency().getRepositories().size()
                    + model.getOverrideBundleDependency().getFeatures().size()
                    + model.getOverrideBundleDependency().getBundles().size() == 0);
            emptyElements.put("bundleReplacements", model.getBundleReplacements().getOverrideBundles().size() == 0);
            emptyElements.put("featureReplacements", model.getFeatureReplacements().getReplacements().size() == 0);

            // A mix of direct write and stream of XML events. It's not easy (without knowing StAX impl) to
            // output self closed tags for example.
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, "UTF-8"));
            writer.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n");
            writer.write("    Configuration generated by Karaf Assembly Builder\n");
            writer.write("-->\n");
            writer.flush();

            Properties props = new Properties();
            props.load(getClass().getResourceAsStream("feature-processing-comments.properties"));

            XMLEventReader xmlEventReader = XMLInputFactory.newFactory().createXMLEventReader(new ByteArrayInputStream(baos.toByteArray()));
            XMLEventWriter xmlEventWriter = new IndentingXMLEventWriter(XMLOutputFactory.newFactory().createXMLEventWriter(writer), "    ");
            XMLEventFactory evFactory = XMLEventFactory.newFactory();
            int depth = 0;
            boolean skipClose = false;
            while (xmlEventReader.hasNext()) {
                XMLEvent ev = xmlEventReader.nextEvent();
                int type = ev.getEventType();
                if (type != XMLEvent.START_DOCUMENT && type != XMLEvent.END_DOCUMENT) {
                    if (type == XMLEvent.START_ELEMENT) {
                        skipClose = false;
                        depth++;
                        if (depth == 2) {
                            String tag = ev.asStartElement().getName().getLocalPart();
                            String comment = props.getProperty(tag);
                            xmlEventWriter.add(evFactory.createCharacters("\n    "));
                            xmlEventWriter.add(evFactory.createComment(" " + comment + " "));
                            if (emptyElements.get(tag) != null && emptyElements.get(tag)) {
                                skipClose = true;
                                writer.write("    <" + tag + " />\n");
                            }
                        }
                    } else if (type == XMLEvent.END_ELEMENT) {
                        skipClose = false;
                        depth--;
                        if (depth == 1) {
                            String tag = ev.asEndElement().getName().getLocalPart();
                            String comment = props.getProperty(tag);
                            if (emptyElements.get(tag) != null && emptyElements.get(tag)) {
                                skipClose = true;
                            }
                        }
                    }
                    if (type == XMLEvent.END_ELEMENT && depth == 0) {
                        xmlEventWriter.add(evFactory.createCharacters("\n"));
                    }
                    if (!skipClose) {
                        xmlEventWriter.add(ev);
                    }
                    if (type == XMLEvent.START_ELEMENT && depth == 1) {
                        xmlEventWriter.add(evFactory.createCharacters("\n"));
                    }
                }
            }
            writer.flush();
        } catch (Exception e) {
            LOG.warn(e.getMessage(), e);
        }
    }

}
