<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head>


  
    <title>Apache Felix - Apache Felix Framework Launching and Embedding</title>
    <link rel="stylesheet" href="apache-felix-framework-launching-and-embedding_files/site.css" type="text/css" media="all">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head><body>
    <div class="title"><div class="logo"><a href="http://felix.apache.org/site/index.html"><img alt="Apache Felix" src="apache-felix-framework-launching-and-embedding_files/logo.png" border="0"></a></div><div class="header"><a href="http://www.apache.org/"><img alt="Apache" src="apache-felix-framework-launching-and-embedding_files/apache.png" border="0"></a></div></div>
    <div class="menu">
<ul>
	<li><a href="http://felix.apache.org/site/news.html" title="news">news</a></li>
	<li><a href="http://felix.apache.org/site/license.html" title="license">license</a></li>
	<li><span class="nobr"><a href="http://felix.apache.org/site/downloads.cgi" title="Visit page outside Confluence" rel="nofollow">downloads<sup><img class="rendericon" src="apache-felix-framework-launching-and-embedding_files/linkext7.gif" alt="" align="absmiddle" border="0" height="7" width="7"></sup></a></span></li>
	<li><a href="http://felix.apache.org/site/documentation.html" title="documentation">documentation</a></li>
	<li><a href="http://felix.apache.org/site/mailinglists.html" title="mailinglists">mailing lists</a></li>
	<li><a href="http://felix.apache.org/site/contributing.html" title="Contributing">contributing</a></li>
	<li><span class="nobr"><a href="http://www.apache.org/" title="Visit page outside Confluence" rel="nofollow">asf<sup><img class="rendericon" src="apache-felix-framework-launching-and-embedding_files/linkext7.gif" alt="" align="absmiddle" border="0" height="7" width="7"></sup></a></span></li>
	<li><span class="nobr"><a href="http://www.apache.org/foundation/sponsorship.html" title="Visit page outside Confluence" rel="nofollow">sponsorship<sup><img class="rendericon" src="apache-felix-framework-launching-and-embedding_files/linkext7.gif" alt="" align="absmiddle" border="0" height="7" width="7"></sup></a></span></li>
	<li><span class="nobr"><a href="http://www.apache.org/foundation/thanks.html" title="Visit page outside Confluence" rel="nofollow">sponsors<sup><img class="rendericon" src="apache-felix-framework-launching-and-embedding_files/linkext7.gif" alt="" align="absmiddle" border="0" height="7" width="7"></sup></a></span>
<!-- ApacheCon Ad -->
<iframe src="apache-felix-framework-launching-and-embedding_files/button.html" style="border-width: 0pt; float: left;" frameborder="0" height="135" scrolling="no" width="135"></iframe>
<p style="height: 100px;">
<!-- ApacheCon Ad -->
</p></li></ul> </div>
    <div class="main">
<h1><a name="ApacheFelixFrameworkLaunchingandEmbedding-ApacheFelixFrameworkLaunchingandEmbedding"></a>Apache Felix Framework Launching and Embedding</h1>

<p><em>[This document is based on Felix 1.4.0.]</em></p>

<ul>
	<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-introduction" title="introduction on Apache Felix Framework Launching and Embedding">Introduction</a></li>
	<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-overview" title="overview on Apache Felix Framework Launching and Embedding">API Overview</a>
	<ul>
		<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-creatingandconfiguring" title="creating-and-configuring on Apache Felix Framework Launching and Embedding">Creating and Configuring the Framework Instance</a></li>
		<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-startinginstance" title="starting-instance on Apache Felix Framework Launching and Embedding">Starting the Framework Instance</a></li>
		<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-stoppinginstance" title="stopping-instance on Apache Felix Framework Launching and Embedding">Stopping the Framework Instance</a></li>
	</ul>
	</li>
	<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-launching" title="launching on Apache Felix Framework Launching and Embedding">Launching Felix</a>
	<ul>
		<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-standardlauncher" title="standard-launcher on Apache Felix Framework Launching and Embedding">Standard Felix Launcher</a></li>
		<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-customlauncher" title="custom-launcher on Apache Felix Framework Launching and Embedding">Custom Felix Launcher</a></li>
	</ul>
	</li>
	<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-embedding" title="embedding on Apache Felix Framework Launching and Embedding">Embedding Felix</a>
	<ul>
		<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-hostinteraction" title="host-interaction on Apache Felix Framework Launching and Embedding">Host/Felix Interaction</a></li>
		<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-hostservices" title="host-services on Apache Felix Framework Launching and Embedding">Providing Host Application Services</a></li>
		<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-hostserviceusage" title="host-service-usage on Apache Felix Framework Launching and Embedding">Using Services Provided by Bundles</a>
		<ul>
			<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-servicereflection" title="service-reflection on Apache Felix Framework Launching and Embedding">Using Bundle Services via Reflection</a></li>
			<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-serviceother" title="service-other on Apache Felix Framework Launching and Embedding">Other Approaches</a></li>
		</ul>
		</li>
	</ul>
	</li>
	<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-caveat" title="caveat on Apache Felix Framework Launching and Embedding">Caveat</a></li>
	<li><a href="#ApacheFelixFrameworkLaunchingandEmbedding-feedback" title="feedback on Apache Felix Framework Launching and Embedding">Feedback</a></li>
</ul>


<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-introduction"></a></p>

<h1><a name="ApacheFelixFrameworkLaunchingandEmbedding-Introduction"></a>Introduction</h1>

<p>The Apache Felix framework is intended to be easily launchable and
embeddable. For example, Felix avoids the use of system properties for
configuration, since these are globals and can cause interference if
multiple framework instances are created in the same VM. Felix also
tries to multiplex singleton facilities, like the URL stream handler
factory. The goal is to make it possible to use Felix in as many
scenarios as possible; however, this is still just a goal. In other
words, this is a work in progress and if any issues arise, it would be
greatly appreciated if they are brought to the attention of the Felix
community. The next section provides a Felix API overview, while the
remainder of the document is divided into two sections, one focusing on
how to launch Felix and one focusing on how to embed Felix into a host
application.</p>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-overview"></a></p>

<h1><a name="ApacheFelixFrameworkLaunchingandEmbedding-APIOverview"></a>API Overview</h1>

<p>The Felix framework is implemented by the <tt>org.apache.felix.framework.Felix</tt> class or just <tt>Felix</tt>
for short. As part of the ongoing OSGi specification process, there is
a movement to standardize the API for launching and embedding OSGi
framework implementations. The approach is to have the framework
implement the <tt>org.osgi.framework.launch.Framework</tt> interface, which extends the <tt>org.osgi.framework.Bundle</tt> interface. These interfaces provide the necessary means to launch and manage framework instances. The <tt>Bundle</tt> interface is defined as:</p>

<div class="code"><div class="codeContent">
<pre class="code-java"><span class="code-keyword">public</span> <span class="code-keyword">interface</span> Bundle
{
    BundleContext getBundleContext();
    <span class="code-object">long</span> getBundleId();
    URL getEntry(<span class="code-object">String</span> name);
    Enumeration getEntryPaths(<span class="code-object">String</span> path);
    Enumeration findEntries(<span class="code-object">String</span> path, <span class="code-object">String</span> filePattern, <span class="code-object">boolean</span> recurse);
    Dictionary getHeaders();
    Dictionary getHeaders(<span class="code-object">String</span> locale);
    <span class="code-object">long</span> getLastModified();
    <span class="code-object">String</span> getLocation();
    URL getResource(<span class="code-object">String</span> name);
    Enumeration getResources(<span class="code-object">String</span> name) <span class="code-keyword">throws</span> IOException;
    ServiceReference[] getRegisteredServices();
    ServiceReference[] getServicesInUse();
    <span class="code-object">int</span> getState();
    <span class="code-object">String</span> getSymbolicName();
    <span class="code-object">boolean</span> hasPermission(<span class="code-object">Object</span> obj);
    <span class="code-object">Class</span> loadClass(<span class="code-object">String</span> name) <span class="code-keyword">throws</span> ClassNotFoundException;
    void start() <span class="code-keyword">throws</span> BundleException;
    void stop() <span class="code-keyword">throws</span> BundleException;
    void uninstall() <span class="code-keyword">throws</span> BundleException;
    void update() <span class="code-keyword">throws</span> BundleException;
    void update(InputStream is) <span class="code-keyword">throws</span> BundleException;
}</pre>
</div></div>

<p>The <tt>Framework</tt> interface is defined as:</p>

<div class="code"><div class="codeContent">
<pre class="code-java"><span class="code-keyword">public</span> <span class="code-keyword">interface</span> Framework <span class="code-keyword">extends</span> Bundle
{
    void init();
    FrameworkEvent waitForStop();
}</pre>
</div></div>

<p>An additional requirement for framework implementations not captured
in the interface definitions is that they must implement a public
constructor that accepts a <tt>Map</tt>, which is used to pass in configuration properties. When you instantiate the <tt>Felix</tt>
class, the resulting object is the actual System Bundle that bundles
inside the framework will see if they get bundle 0, which is the System
Bundle as defined by the OSGi specification.</p>

<table class="warningMacro" align="center" border="0" cellpadding="5" cellspacing="8" width="85%"><colgroup><col width="24"><col></colgroup><tbody><tr><td valign="top"><img src="apache-felix-framework-launching-and-embedding_files/forbidden.gif" alt="" align="absmiddle" border="0" height="16" width="16"></td><td><b class="strong">WARNING</b><br>
<p>This API is undergoing changes and is not completely finalized, so future changes are possible.</p></td></tr></tbody></table>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-creatingandconfiguring"></a></p>

<h2><a name="ApacheFelixFrameworkLaunchingandEmbedding-CreatingandConfiguringtheFrameworkInstance"></a>Creating and Configuring the Framework Instance</h2>

<p>To create a framework instance, simply instantiate the <tt>Felix</tt> class. A newly created framework instance is in the <tt>Bundle.INSTALLED</tt> state. You configure the instance by passing the constructor a <tt>Map</tt> containing its configurations properties. The configuration map may contain the following OSGi standard properties:</p>

<ul>
	<li><tt>org.osgi.framework.system.packages</tt> - specifies a
list of packages the system bundle should export from the environment;
if this is not set, then the framework uses a reasonable default fault.</li>
	<li><tt>org.osgi.framework.system.packages.extra</tt>
- specifies a list of additional packages the system bundle should
export from the environment that are appended to the packages specified
in <tt>org.osgi.framework.system.packages</tt>; there is no default value for this property.</li>
	<li><tt>org.osgi.framework.bootdelegation</tt>
- specifies a list of packages that should be made implicitly available
to all bundles from the environment (i.e., no need to import them);
there is no default value for this property and its use should be
avoided.</li>
	<li><tt>org.osgi.framework.storage</tt> - specifies the
path to a directory, which will be created if it does not exist, to use
for bundle cache storage; the default value for this property is "<tt>felix-cache</tt>" in the current working directory.</li>
	<li><tt>org.osgi.framework.storage.clean</tt>
- specifies whether the bundle cache should be flushed; the default
value for this property is "none", but it can be changed to
"onFirstInit" to flush the bundle cache when the framework is
initialized.</li>
	<li><tt>org.osgi.framework.startlevel</tt> - specifies the start level the framework enters upon startup; the default value for this property is 1.</li>
</ul>


<p>Felix also has the following, non-standard configuration properties:</p>

<ul>
	<li><tt>felix.cache.rootdir</tt> - specifies which directory should be used to calculate absolute paths when relative paths are used for the <tt>org.osgi.framework.storage</tt> property; the default value for this property is the current working directory.</li>
	<li><tt>felix.systembundle.activators</tt> - specifies a <tt>List</tt> of <tt>BundleActivator</tt>
instances that are started/stopped when the System Bundle is
started/stopped; the specified instances will receive the System
Bundle's <tt>BundleContext</tt> when invoked.</li>
	<li><tt>felix.log.logger</tt> - specifies an instance of <tt>org.apache.felix.framework.util.Logger</tt> that the framework uses as its default logger.</li>
	<li><tt>felix.log.level</tt> - specifies an integer <tt>String</tt>
whose value indicates the degree of logging reported by the framework;
the default value is "1" and "0" turns off logging completely,
otherwise log levels match those specified in the OSGi Log Service
(i.e., 1 = error, 2 = warning, 3 = information, and 4 = debug).</li>
	<li><tt>felix.startlevel.bundle</tt> - specifies the start level for newly installed bundles; the default value is 1.</li>
	<li><tt>framework.service.urlhandlers</tt>
- specifies whether or not to activate the URL Handlers service for the
framework instance; the default value is "&lt;tt&gt;true&lt;/tt&gt;",
which results in the
&lt;tt&gt;URL.setURLStreamHandlerFactory()&lt;/tt&gt; and
&lt;tt&gt;URLConnection.setContentHandlerFactory()&lt;/tt&gt; being
called.</li>
</ul>


<p>The configuration map passed into the constructor is copied and the
keys are treated as case insensitive. You are not able to change the
framework's configuration after construction. If you need a different
configuration, you must create a new framework instance.</p>

<table class="warningMacro" align="center" border="0" cellpadding="5" cellspacing="8" width="85%"><colgroup><col width="24"><col></colgroup><tbody><tr><td valign="top"><img src="apache-felix-framework-launching-and-embedding_files/forbidden.gif" alt="" align="absmiddle" border="0" height="16" width="16"></td><td><b class="strong">WARNING</b><br>
<p>Felix <tt>1.4.0</tt> introduced some significant changes to its configuration properties; if you are upgrading from a previous version, the <a href="http://felix.apache.org/site/apache-felix-usage-documentation.html#ApacheFelixUsageDocumentation-migrating" title="migrating on Apache Felix Usage Documentation">usage document</a> describes the configuration property changes.</p></td></tr></tbody></table>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-startinginstance"></a></p>

<h2><a name="ApacheFelixFrameworkLaunchingandEmbedding-StartingtheFrameworkInstance"></a>Starting the Framework Instance</h2>

<p>The <tt>start()</tt> method is used to start the framework instance. If the <tt>init()</tt> method was not invoked prior to calling <tt>start()</tt>, then it is implicitly invoked from <tt>start()</tt>. The two methods result in two different framework state transitions:</p>

<ul>
	<li><tt>init()</tt> results in the framework instance in the <tt>Bundle.STARTING</tt> state.</li>
	<li><tt>start()</tt> results in the framework instance in the <tt>Bundle.ACTIVE</tt> state.</li>
</ul>


<p>The <tt>init()} method is necessary since the framework does not have a {{BundleContext</tt> when it is first created, so a transition to the <tt>Bundle.STARTING</tt> state is required to acquire its context (via <tt>Bundle.getBundleContext()</tt>) for performing various tasks, such as installing bundles. Note that Felix also provides the <tt>felix.systembundle.activators</tt> property that serves a similar purpose. After the <tt>init()</tt> method completes, the follow actions have been performed:</p>

<ul>
	<li>Event handling is enabled.</li>
	<li>The security manager is installed if it is enabled.</li>
	<li>The framework is set to start level 0.</li>
	<li>All bundles in the bundle caches are reified and their state is set to <tt>Bundle.INSTALLED</tt>.</li>
	<li>The framework gets a valid <tt>BundleContext</tt>.</li>
	<li>All framework-provided services are made available (e.g., PackageAdmin, StartLevel, etc.).</li>
	<li>The framework enters the <tt>Bundle.STARTING</tt> state.</li>
</ul>


<p>A call to <tt>start()</tt> is necessary to start the framework instance, if the <tt>init()</tt> method is invoked manually. Invoking <tt>init()</tt> or <tt>start()</tt> on an already started framework as no effect.</p>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-stoppinginstance"></a></p>

<h2><a name="ApacheFelixFrameworkLaunchingandEmbedding-StoppingtheFrameworkInstance"></a>Stopping the Framework Instance</h2>

<p>To stop the framework instance, invoke the <tt>stop()</tt> method, which will asynchronously stop the framework. To know when the framework has finished its shutdown sequence, use the <tt>waitForStop()</tt> method to wait until it is complete. A stopped framework will be in the <tt>Bundle.RESOLVED</tt> state. It is possible to restart the framework, using the normal combination of <tt>init()</tt>/<tt>start()</tt> methods as previously described.</p>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-launching"></a></p>

<h1><a name="ApacheFelixFrameworkLaunchingandEmbedding-LaunchingFelix"></a>Launching Felix</h1>

<p>Launching Felix is fairly simple and involves only three steps:</p>

<ol>
	<li>Define some configuration properties.</li>
	<li>Create an instance of <tt>org.apache.felix.framework.Felix</tt> with the configuration properties.</li>
	<li>Invoke the <tt>org.apache.felix.framework.Felix.start()</tt> method.</li>
</ol>


<p>In reality, the first step is optional, since all properties will
have reasonable defaults, but if you are creating a launcher you will
generally want to more than that, such as automatically installing and
starting bundles when you start the framework instance. The default
Felix launcher defines reusable functionality to automatically install
and/or start bundles upon framework startup; see the <a href="http://felix.apache.org/site/apache-felix-usage-documentation.html#ApacheFelixUsageDocumentation-configuringfelix" title="configuring-felix on Apache Felix Usage Documentation">usage document</a> for more information on configuring Felix and on the various configuration properties.</p>

<p>The remainder of this section describes how the standard Felix
launcher works as well as how to create a custom launcher for Felix.</p>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-standardlauncher"></a></p>

<h2><a name="ApacheFelixFrameworkLaunchingandEmbedding-StandardFelixLauncher"></a>Standard Felix Launcher</h2>

<p>The standard Felix launcher is very simple and is not intended to
solve every possible requirement; it is intended to work for most
standard situations. Most special launching requirements should be
resolved by creating a custom launcher. This section describes how the
standard launcher works. The following code represents the complete <tt>main()</tt> method of the standard launcher, each numbered comment will be described in more detail below:</p>

<div class="code"><div class="codeContent">
<pre class="code-java"><span class="code-keyword">public</span> <span class="code-keyword">static</span> void main(<span class="code-object">String</span>[] argv) <span class="code-keyword">throws</span> Exception
{
    <span class="code-comment">// (1) Check <span class="code-keyword">for</span> proper command line usage.
</span>    <span class="code-keyword">if</span> (args.length &gt; 1)
    {
        <span class="code-object">System</span>.out.println(<span class="code-quote">"Usage: [&lt;bundle-cache-dir&gt;]"</span>);
        <span class="code-object">System</span>.exit(0);
    }

    <span class="code-comment">// (2) Load system properties.
</span>    Main.loadSystemProperties();

    <span class="code-comment">// (3) Read configuration properties.
</span>    Properties configProps = Main.loadConfigProperties();

    <span class="code-comment">// (4) Copy framework properties from the system properties.
</span>    Main.copySystemProperties(configProps);

    <span class="code-comment">// (5) If specified, use command-line argument as path to bundle cache.
</span>    <span class="code-keyword">if</span> (args.length &gt; 0)
    {
        configProps.setProperty(Constants.FRAMEWORK_STORAGE, args[0]);
    }

    <span class="code-comment">// (6) Create a list <span class="code-keyword">for</span> custom framework activators and
</span>    <span class="code-comment">// add an instance of the auto-activator it <span class="code-keyword">for</span> processing
</span>    <span class="code-comment">// auto-install and auto-start properties. Add <span class="code-keyword">this</span> list
</span>    <span class="code-comment">// to the configuration properties.
</span>    List list = <span class="code-keyword">new</span> ArrayList();
    list.add(<span class="code-keyword">new</span> AutoActivator(configProps));
    configProps.put(FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list);

    <span class="code-comment">// Print welcome banner.
</span>    <span class="code-object">System</span>.out.println(<span class="code-quote">"\nWelcome to Felix."</span>);
    <span class="code-object">System</span>.out.println(<span class="code-quote">"=================\n"</span>);

    <span class="code-keyword">try</span>
    {
        <span class="code-comment">// (7) Create an instance and start the framework.
</span>
        m_felix = <span class="code-keyword">new</span> Felix(configProps);
        m_felix.start();
        <span class="code-comment">// (8) Wait <span class="code-keyword">for</span> framework to stop to exit the VM.
</span>        m_felix.waitForStop();
        <span class="code-object">System</span>.exit(0);
    }
    <span class="code-keyword">catch</span> (Exception ex)
    {
        <span class="code-object">System</span>.err.println(<span class="code-quote">"Could not create framework: "</span> + ex);
        ex.printStackTrace();
        <span class="code-object">System</span>.exit(-1);
    }
}</pre>
</div></div>

<p>The general steps of the standard launcher are quite straightforward:</p>

<ol>
	<li>The launcher only supports a single, optional command-line
argument, which is the path to the bundle cache, so check for this and
issue a usage message it there are more than one arguments.</li>
	<li>Load any system properties specified in the <tt>system.properties</tt> file; this file is typically located in the <tt>conf/</tt> directory of the Felix installation directory, but it can be specified directly using the <tt>felix.system.properties</tt>
system property. This file is not needed to launch Felix and is
provided merely for convenience when system properties must be
specified. The file is a standard Java properties file, but it also
supports property substitution using <tt>${&lt;property-name</tt>} syntax. Property substitution can be nested; only system properties will be used for substitution.</li>
	<li>Load any configuration properties specified in the <tt>config.properties</tt> file; this file is typically located in the <tt>conf/</tt> directory of the Felix installation directory, but it can be specified directly using the <tt>felix.config.properties</tt>
system property. This file is used to configure the Felix instance
created by the launcher. The file is a standard Java properties file,
but it also supports property substitution using "<tt>${&lt;property-name</tt>}"
syntax. Property substitution can be nested; configuration and system
properties will be used for substitution with configuration properties
having precedence.</li>
	<li>For convenience, any configuration
properties that are set as system properties will be copied into the
set of configuration properties to provide an easy way to add to or
override configuration properties specified in the <tt>config.properties</tt> file.</li>
	<li>If there is a single command-line argument, then use that to set the value of <tt>org.osgi.framework.storage</tt>; relative paths are relative to the current directory unless the <tt>felix.cache.rootdir</tt> property is set.</li>
	<li>Create a list to hold custom framework activators and add an instance of <tt>org.apache.felix.main.AutoActivator</tt>, which will process <tt>felix.auto.install</tt> and <tt>felix.auto.start</tt> configuration properties during framework startup to automatically install and/or start bundles; see the <a href="http://felix.apache.org/site/apache-felix-usage-documentation.html#ApacheFelixUsageDocumentation-configuringfelix" title="configuring-felix on Apache Felix Usage Documentation">usage document</a> for more information configuration properties.</li>
	<li>Create the Felix instance passing in the configuration properties, then call <tt>start()</tt>.</li>
	<li>Invoke <tt>waitForStop()</tt> to wait for the framework to stop to force the VM to exit; this is necessary because the framework never calls <tt>System.exit()</tt> and some libraries (e.g., Swing) create threads that will not allow the VM to exit.</li>
</ol>


<p>The framework is not active until the <tt>start()</tt> method is
called. If no shell bundles are installed and started or if there is
difficulty locating the shell bundles specified in the auto-start
property, then it will appear as if the framework is hung, but it is
actually running without any way to interact with it since the shell
bundles provide the only means of interaction.</p>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-customlauncher"></a></p>

<h2><a name="ApacheFelixFrameworkLaunchingandEmbedding-CustomFelixLauncher"></a>Custom Felix Launcher</h2>

<p>This section creates a bare-bones launcher to demonstrate the
minimum requirements for creating an interactive launcher for the Felix
framework. This example uses the standard Felix shell bundles for
interactivity, but any other bundles could be used instead. For
example, the shell service and telnet bundles could be used to launch
Felix and make it remotely accessible.</p>

<p>This example launcher project has the following directory structure:</p>

<div class="preformatted"><div class="preformattedContent">
<pre>launcher/
   lib/
      org.apache.felix.main-1.4.0.jar
   bundle/
      org.apache.felix.shell-1.0.2.jar
      org.apache.felix.shell.tui-1.0.2.jar
   src/
      example/
         Main.java
</pre>
</div></div>

<p>The <tt>lib/</tt> directory contains Felix' main JAR file, which
also contains the OSGi core interfaces. The main JAR file is used so
that we can reuse the default launcher's auto-install/auto-start
configuration property handling; if these capabilities are not needed,
then it would be possible to use the framework JAR file instead of the
main JAR file. The <tt>bundle/</tt> directory contains the shell
service and textual shell interface bundles that will be used for
interacting with the framework instance. Note: If you do not launch
Felix with interactive bundles, it will appear as if the framework
instance is hung, but it is actually just sitting there waiting for
someone to tell it to do something. The <tt>src/example/</tt> directory contains the following <tt>Main.java</tt> file, which is a very simplistic Felix launcher.</p>

<div class="code"><div class="codeContent">
<pre class="code-java"><span class="code-keyword">package</span> example;

<span class="code-keyword">import</span> java.util.ArrayList;
<span class="code-keyword">import</span> java.util.List;
<span class="code-keyword">import</span> java.util.Map;
<span class="code-keyword">import</span> java.util.HashMap;
<span class="code-keyword">import</span> org.osgi.framework.Constants;
<span class="code-keyword">import</span> org.apache.felix.framework.Felix;
<span class="code-keyword">import</span> org.apache.felix.framework.util.FelixConstants;
<span class="code-keyword">import</span> org.apache.felix.main.AutoActivator;

<span class="code-keyword">public</span> class Main
{
    <span class="code-keyword">private</span> <span class="code-keyword">static</span> Felix m_felix = <span class="code-keyword">null</span>;

    <span class="code-keyword">public</span> <span class="code-keyword">static</span> void main(<span class="code-object">String</span>[] argv) <span class="code-keyword">throws</span> Exception
    {
        <span class="code-comment">// Print welcome banner.
</span>        <span class="code-object">System</span>.out.println(<span class="code-quote">"\nWelcome to Felix."</span>);
        <span class="code-object">System</span>.out.println(<span class="code-quote">"=================\n"</span>);

        Map configMap = <span class="code-keyword">new</span> HashMap();
        configMap.put(AutoActivator.AUTO_START_PROP + <span class="code-quote">".1"</span>,
            <span class="code-quote">"file:bundle/org.apache.felix.shell-1.0.2.jar "</span> +
            <span class="code-quote">"file:bundle/org.apache.felix.shell.tui-1.0.2.jar"</span>);
        List list = <span class="code-keyword">new</span> ArrayList();
        list.add(<span class="code-keyword">new</span> AutoActivator(configMap));
        configMap.put(FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list);

        <span class="code-keyword">try</span>
        {
            m_felix = <span class="code-keyword">new</span> Felix(configMap);
            m_felix.start();
            m_felix.waitForStop();
            <span class="code-object">System</span>.exit(0);
        }
        <span class="code-keyword">catch</span> (Exception ex)
        {
            <span class="code-object">System</span>.err.println(<span class="code-quote">"Could not create framework: "</span> + ex);
            ex.printStackTrace();
            <span class="code-object">System</span>.exit(-1);
        }
    }
}</pre>
</div></div>

<p>This launcher has all information hard coded in it, unlike the
default Felix launcher, which loads configuration properties from files
and performs variable substitution. This simple launcher provides a
good starting point if the features of the default launcher are not
necessary. Since very few configuration properties are specified, the
default values are used. In the case of the framework bundle cache, it
will use "<tt>felix-cache</tt>" in the current directory.</p>

<p>By breaking down the above source code into small chunks, it is quite easy to see what is going on.</p>

<div class="code"><div class="codeContent">
<pre class="code-java">Map configMap = <span class="code-keyword">new</span> HashMap();</pre>
</div></div>

<p>This simply creates a map to hold configuration properties.</p>

<div class="code"><div class="codeContent">
<pre class="code-java">configMap.put(AutoActivator.AUTO_START_PROP + <span class="code-quote">".1"</span>,
            <span class="code-quote">"file:bundle/org.apache.felix.shell-1.0.2.jar "</span> +
            <span class="code-quote">"file:bundle/org.apache.felix.shell.tui-1.0.2.jar"</span>);</pre>
</div></div>

<p>This sets the <tt>AutoActivator.AUTO_START_PROP</tt> configuration property (string value "<tt>felix.auto.start</tt>"),
which is a space-delimited list of bundle URLs that the framework will
automatically install and start when the framework starts. However,
this property key cannot be used as is; it must be appended with a "."
and then a number, where the number represents the start level for the
bundle when it is installed. In this particular example, ".1" is
appended to the property name, thus the two bundles will be installed
into start level one. This example uses relative <tt>file:</tt> URLs, which will load the bundles from the <tt>bundle/</tt>
directory assuming that the launcher is started from the root directory
of the launcher project. It is also possible to specify absolute URLs
or remote URLs.</p>

<div class="code"><div class="codeContent">
<pre class="code-java">List list = <span class="code-keyword">new</span> ArrayList();
        list.add(<span class="code-keyword">new</span> AutoActivator(configMap));
        configMap.put(FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list);</pre>
</div></div>

<p>This above creates a list to hold custom framework activators and adds an instance of <tt>org.apache.felix.main.AutoActivator</tt>
to it, which will process the auto-install and auto-start configuration
properties during framework startup. The list of activators is then
added to the configuration map.</p>

<div class="code"><div class="codeContent">
<pre class="code-java">m_felix = <span class="code-keyword">new</span> Felix(configMap);
            m_felix.start();</pre>
</div></div>

<p>These steps create the framework instance and start it. The configuration property map is passed into the <tt>Felix</tt> constructor.</p>

<div class="code"><div class="codeContent">
<pre class="code-java">m_felix.waitForStop();
            <span class="code-object">System</span>.exit(0);</pre>
</div></div>

<p>These final steps cause the launching application thread to wait for
the framework to stop and when it does the launching thread calls <tt>System.exit()</tt> to make sure the VM actually exits.</p>

<p>The following command compiles the launcher when run from the root directory of the launcher project:</p>

<div class="preformatted"><div class="preformattedContent">
<pre>javac -d . -classpath lib/org.apache.felix.main-1.4.0.jar src/example/Main.java
</pre>
</div></div>

<p>After executing this command, an <tt>example/</tt> directory is
created in the current directory, which contains the generated class
file. The following command executes the simple launcher when run from
the root directory of the launcher project:</p>

<div class="preformatted"><div class="preformattedContent">
<pre>java -cp .:lib/org.apache.felix.main-1.4.0.jar example.Main
</pre>
</div></div>

<p>After executing this command, a "<tt>felix-cache/</tt>" directory is created that contains the installed bundles, which were installed from the <tt>bundle/</tt> directory.</p>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-embedding"></a></p>

<h1><a name="ApacheFelixFrameworkLaunchingandEmbedding-EmbeddingFelix"></a>Embedding Felix</h1>

<p>Embedding Felix into a host application is a simple way to provide a
sophisticated extensibility mechanism (i.e., a plugin system) to the
host application. Embedding Felix is very similar to launching Felix as
described above, the main difference is that the host application
typically wants to interact with the framework instance and/or
installed bundles/services from the outside. This is fairly easy to
achieve with Felix, but there are some subtle issues to understand.
This section presents the mechanisms for embedding Felix into a host
application and the issues in doing so.</p>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-hostinteraction"></a></p>

<h2><a name="ApacheFelixFrameworkLaunchingandEmbedding-Host/FelixInteraction"></a>Host/Felix Interaction</h2>

<p>In the section on <a href="#ApacheFelixFrameworkLaunchingandEmbedding-launching" title="launching on Apache Felix Framework Launching and Embedding">launching</a> Felix above, the <tt>Felix</tt> accepts a configuration property called <tt>felix.systembundle.activators</tt>,
which is a list of bundle activator instances. These bundle activator
instances provide a convenient way for host applications to interact
with the Felix framework. The ability offered by these activators can
also be accomplished by invoking <tt>init()</tt> on the framework instance and the using <tt>getBundleContext()</tt> to get the System Bundle's context, but it can be more convenient to use an activator instance.</p>

<p>Each activator instance passed into the constructor effectively becomes part of the System Bundle. This means that the <tt>start()</tt>/<tt>stop()</tt> methods of each activator instance in the list gets invoked when the System Bundle's activator <tt>start()</tt>/<tt>stop()</tt> methods gets invoked, respectively. Each activator instance will be given the System Bundle's <tt>BundleContext</tt> object so that they can interact with the framework. Consider following snippet of a bundle activator:</p>

<div class="code"><div class="codeContent">
<pre class="code-java"><span class="code-keyword">public</span> class HostActivator <span class="code-keyword">implements</span> BundleActivator
{
    <span class="code-keyword">private</span> BundleContext m_context = <span class="code-keyword">null</span>;

    <span class="code-keyword">public</span> void start(BundleContext context)
    {
        m_context = context;
    }

    <span class="code-keyword">public</span> void stop(BundleContext context)
    {
        m_context = <span class="code-keyword">null</span>;
    }

    <span class="code-keyword">public</span> Bundle[] getBundles()
    {
        <span class="code-keyword">if</span> (m_context != <span class="code-keyword">null</span>)
        {
            <span class="code-keyword">return</span> m_context.getBundles();
        }
        <span class="code-keyword">return</span> <span class="code-keyword">null</span>;
    }
}</pre>
</div></div>

<p>Given the above bundle activator, it is now possible to embed Felix
into a host application and interact with it as the following snippet
illustrates:</p>

<div class="code"><div class="codeContent">
<pre class="code-java"><span class="code-keyword">public</span> class HostApplication
{
    <span class="code-keyword">private</span> HostActivator m_activator = <span class="code-keyword">null</span>;
    <span class="code-keyword">private</span> Felix m_felix = <span class="code-keyword">null</span>;

    <span class="code-keyword">public</span> HostApplication()
    {
        <span class="code-comment">// Create a configuration property map.
</span>        Map configMap = <span class="code-keyword">new</span> HashMap();
        <span class="code-comment">// Create host activator;
</span>        m_activator = <span class="code-keyword">new</span> HostActivator();
        List list = <span class="code-keyword">new</span> ArrayList();
        list.add(m_activator);
        configMap.put(FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list);

        <span class="code-keyword">try</span>
        {
            <span class="code-comment">// Now create an instance of the framework with
</span>            <span class="code-comment">// our configuration properties.
</span>            m_felix = <span class="code-keyword">new</span> Felix(configMap);
            <span class="code-comment">// Now start Felix instance.
</span>            m_felix.start();
        }
        <span class="code-keyword">catch</span> (Exception ex)
        {
            <span class="code-object">System</span>.err.println(<span class="code-quote">"Could not create framework: "</span> + ex);
            ex.printStackTrace();
        }
    }

    <span class="code-keyword">public</span> Bundle[] getInstalledBundles()
    {
        <span class="code-comment">// Use the system bundle activator to gain external
</span>        <span class="code-comment">// access to the set of installed bundles.
</span>        <span class="code-keyword">return</span> m_activator.getBundles();
    }

    <span class="code-keyword">public</span> void shutdownApplication()
    {
        <span class="code-comment">// Shut down the felix framework when stopping the
</span>        <span class="code-comment">// host application.
</span>        m_felix.stop();
        m_felix.waitForStop();
    }
}</pre>
</div></div>

<p>Notice how the <tt>HostApplication.getInstalledBundles()</tt> method
uses its activator instance to get access to the System Bundle's
context in order to interact with the embedded Felix framework
instance. This approach provides the foundation for all interaction
between the host application and the embedded framework instance.</p>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-hostservices"></a></p>

<h2><a name="ApacheFelixFrameworkLaunchingandEmbedding-ProvidingHostApplicationServices"></a>Providing Host Application Services</h2>

<p>Providing services from the host application to bundles inside the
embedded Felix framework instance follows the basic approach laid out
in <a href="#ApacheFelixFrameworkLaunchingandEmbedding-hostinteraction" title="host-interaction on Apache Felix Framework Launching and Embedding">above</a>.
The main complication for providing a host application service to
bundles is the fact that both the host application and the bundles must
be using the same class definitions for the service interface classes.
Since the host application cannot import classes from a bundle, this
means that the service interface classes <b>must</b> be accessible on
the class path, typically as part of the host application itself. The
host application then must export the service interface package via the
system bundle so that bundles installed into the embedded framework
instance can import it. This is achieved using the <tt>org.osgi.framework.system.packages.extra</tt> configuration property previously presented.</p>

<p>Consider the follow simple property lookup service:</p>

<div class="code"><div class="codeContent">
<pre class="code-java"><span class="code-keyword">package</span> host.service.lookup;

<span class="code-keyword">public</span> class Lookup
{
    <span class="code-keyword">public</span> <span class="code-object">Object</span> lookup(<span class="code-object">String</span> name);
}</pre>
</div></div>

<p>This package is simply part of the host application, which is potentially packaged into a JAR file and started with the "<tt>java -jar</tt>"
command. Now consider the following host application bundle activator,
which will be used to register/unregister the property lookup service
when the embedded framework instance starts/stops:</p>

<div class="code"><div class="codeContent">
<pre class="code-java"><span class="code-keyword">package</span> host.core;

<span class="code-keyword">import</span> java.util.Map;
<span class="code-keyword">import</span> org.osgi.framework.BundleActivator;
<span class="code-keyword">import</span> org.osgi.framework.BundleContext;
<span class="code-keyword">import</span> org.osgi.framework.ServiceRegistration;
<span class="code-keyword">import</span> host.service.lookup;

<span class="code-keyword">public</span> class HostActivator <span class="code-keyword">implements</span> BundleActivator
{
    <span class="code-keyword">private</span> Map m_lookupMap = <span class="code-keyword">null</span>;
    <span class="code-keyword">private</span> BundleContext m_context = <span class="code-keyword">null</span>;
    <span class="code-keyword">private</span> ServiceRegistration m_registration = <span class="code-keyword">null</span>;

    <span class="code-keyword">public</span> HostActivator(Map lookupMap)
    {
        <span class="code-comment">// Save a reference to the service's backing store.
</span>        m_lookupMap = lookupMap;
    }

    <span class="code-keyword">public</span> void start(BundleContext context)
    {
        <span class="code-comment">// Save a reference to the bundle context.
</span>        m_context = context;
        <span class="code-comment">// Create a property lookup service implementation.
</span>        Lookup lookup = <span class="code-keyword">new</span> Lookup() {
            <span class="code-keyword">public</span> <span class="code-object">Object</span> lookup(<span class="code-object">String</span> name)
            {
                <span class="code-keyword">return</span> m_lookupMap.get(name);
            }
        };
        <span class="code-comment">// Register the property lookup service and save
</span>        <span class="code-comment">// the service registration.
</span>        m_registration = m_context.registerService(
            Lookup.class.getName(), lookup, <span class="code-keyword">null</span>);
    }

    <span class="code-keyword">public</span> void stop(BundleContext context)
    {
        <span class="code-comment">// Unregister the property lookup service.
</span>        m_registration.unregister();
        m_context = <span class="code-keyword">null</span>;
    }
}</pre>
</div></div>

<p>Given the above host application bundle activator, the following
code snippet shows how the host application could create an embedded
version of the Felix framework and provide the property lookup service
to installed bundles:</p>

<div class="code"><div class="codeContent">
<pre class="code-java"><span class="code-keyword">package</span> host.core;

<span class="code-keyword">import</span> java.util.List;
<span class="code-keyword">import</span> java.util.ArrayList;
<span class="code-keyword">import</span> java.util.Map;
<span class="code-keyword">import</span> java.util.HashMap;
<span class="code-keyword">import</span> host.service.lookup.Lookup;
<span class="code-keyword">import</span> org.apache.felix.framework.Felix;
<span class="code-keyword">import</span> org.apache.felix.framework.util.FelixConstants;
<span class="code-keyword">import</span> org.osgi.framework.Constants;

<span class="code-keyword">public</span> class HostApplication
{
    <span class="code-keyword">private</span> HostActivator m_activator = <span class="code-keyword">null</span>;
    <span class="code-keyword">private</span> Felix m_felix = <span class="code-keyword">null</span>;
    <span class="code-keyword">private</span> Map m_lookupMap = <span class="code-keyword">new</span> HashMap();

    <span class="code-keyword">public</span> HostApplication()
    {
        <span class="code-comment">// Initialize the map <span class="code-keyword">for</span> the property lookup service.
</span>        m_lookupMap.put(<span class="code-quote">"name1"</span>, <span class="code-quote">"value1"</span>);

        m_lookupMap.put(<span class="code-quote">"name2"</span>, <span class="code-quote">"value2"</span>);
        m_lookupMap.put(<span class="code-quote">"name3"</span>, <span class="code-quote">"value3"</span>);
        m_lookupMap.put(<span class="code-quote">"name4"</span>, <span class="code-quote">"value4"</span>);

        <span class="code-comment">// Create a configuration property map.
</span>        Map configMap = <span class="code-keyword">new</span> HashMap();
        <span class="code-comment">// Export the host provided service <span class="code-keyword">interface</span> <span class="code-keyword">package</span>.
</span>        configMap.put(Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA,
            <span class="code-quote">"host.service.lookup; version=1.0.0"</span>);
        <span class="code-comment">// Create host activator;
</span>        m_activator = <span class="code-keyword">new</span> HostActivator(m_lookupMap);
        List list = <span class="code-keyword">new</span> ArrayList();
        list.add(m_activator);
        configMap.put(FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list);

        <span class="code-keyword">try</span>
        {
            <span class="code-comment">// Now create an instance of the framework with
</span>            <span class="code-comment">// our configuration properties.
</span>            m_felix = <span class="code-keyword">new</span> Felix(configMap);
            <span class="code-comment">// Now start Felix instance.
</span>            m_felix.start();
        }
        <span class="code-keyword">catch</span> (Exception ex)
        {
            <span class="code-object">System</span>.err.println(<span class="code-quote">"Could not create framework: "</span> + ex);
            ex.printStackTrace();
        }
    }

    <span class="code-keyword">public</span> void shutdownApplication()
    {
        <span class="code-comment">// Shut down the felix framework when stopping the
</span>        <span class="code-comment">// host application.
</span>        m_felix.stop();
        m_felix.waitForStop();
    }
}</pre>
</div></div>

<p>Rather than having the host application bundle activator register
the service, it is also possible for the the host application to simply
get the bundle context from the bundle activator and register the
service directly, but the presented approach is perhaps a little
cleaner since it allows the host application to register/unregister the
service when the system bundle starts/stops.</p>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-hostserviceusage"></a></p>

<h2><a name="ApacheFelixFrameworkLaunchingandEmbedding-UsingServicesProvidedbyBundles"></a>Using Services Provided by Bundles</h2>

<p>Using services provided by bundles follows the same general approach
of using a host application bundle activator. The main complication for
the host application using a service from a bundle is the fact that
both the host application and the bundle must be using the same class
definitions for the service interface classes. Since the host
application cannot import classes from a bundle, this means that the
service interface classes <b>must</b> be accessible on the class path,
typically as part of the host application itself. The host application
then must export the service interface package via the system bundle so
that bundles installed into the embedded framework instance can import
it. This is achieved using the <tt>org.osgi.framework.system.packages.extra</tt> configuration property previously presented.</p>

<p>Consider the following simple command service interface for which
bundles provide implementations, such as might be used to create an
extensible interactive shell:</p>

<div class="code"><div class="codeContent">
<pre class="code-java"><span class="code-keyword">package</span> host.service.command;

<span class="code-keyword">public</span> class Command
{
    <span class="code-keyword">public</span> <span class="code-object">String</span> getName();
    <span class="code-keyword">public</span> <span class="code-object">String</span> getDescription();
    <span class="code-keyword">public</span> <span class="code-object">boolean</span> execute(<span class="code-object">String</span> commandline);
}</pre>
</div></div>

<p>This package is simply part of the host application, which is potentially packaged into a JAR file and started with the "<tt>java -jar</tt>"
command. Now consider the previously introduced host application bundle
activator below, which simply provides access to the system bundle
context:</p>

<div class="code"><div class="codeContent">
<pre class="code-java"><span class="code-keyword">package</span> host.core;

<span class="code-keyword">import</span> org.osgi.framework.BundleActivator;
<span class="code-keyword">import</span> org.osgi.framework.BundleContext;

<span class="code-keyword">public</span> class HostActivator <span class="code-keyword">implements</span> BundleActivator
{
    <span class="code-keyword">private</span> BundleContext m_context = <span class="code-keyword">null</span>;

    <span class="code-keyword">public</span> void start(BundleContext context)
    {
        m_context = context;
    }

    <span class="code-keyword">public</span> void stop(BundleContext context)
    {
        m_context = <span class="code-keyword">null</span>;
    }

    <span class="code-keyword">public</span> BundleContext getContext()
    {
        <span class="code-keyword">return</span> m_context;
    }
}</pre>
</div></div>

<p>With this bundle activator, the host application can use command
services provided by bundles installed inside its embedded Felix
framework instance. The following code snippet illustrates one possible
approach:</p>

<div class="code"><div class="codeContent">
<pre class="code-java"><span class="code-keyword">package</span> host.core;

<span class="code-keyword">import</span> java.util.List;
<span class="code-keyword">import</span> java.util.ArrayList;
<span class="code-keyword">import</span> java.util.Map;
<span class="code-keyword">import</span> host.service.command.Command;
<span class="code-keyword">import</span> org.apache.felix.framework.Felix;
<span class="code-keyword">import</span> org.apache.felix.framework.util.FelixConstants;
<span class="code-keyword">import</span> org.apache.felix.framework.cache.BundleCache;
<span class="code-keyword">import</span> org.osgi.framework.Constants;
<span class="code-keyword">import</span> org.osgi.util.tracker.ServiceTracker;

<span class="code-keyword">public</span> class HostApplication
{
    <span class="code-keyword">private</span> HostActivator m_activator = <span class="code-keyword">null</span>;
    <span class="code-keyword">private</span> Felix m_felix = <span class="code-keyword">null</span>;
    <span class="code-keyword">private</span> ServiceTracker m_tracker = <span class="code-keyword">null</span>;

    <span class="code-keyword">public</span> HostApplication()
    {
        <span class="code-comment">// Create a configuration property map.
</span>        Map configMap = <span class="code-keyword">new</span> HashMap();
        <span class="code-comment">// Export the host provided service <span class="code-keyword">interface</span> <span class="code-keyword">package</span>.
</span>        configMap.put(Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA,
            <span class="code-quote">"host.service.command; version=1.0.0"</span>);
        <span class="code-comment">// Create host activator;
</span>        m_activator = <span class="code-keyword">new</span> HostActivator();
        List list = <span class="code-keyword">new</span> ArrayList();
        list.add(m_activator);
        configMap.put(FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list);

        <span class="code-keyword">try</span>
        {
            <span class="code-comment">// Now create an instance of the framework with
</span>            <span class="code-comment">// our configuration properties.
</span>            m_felix = <span class="code-keyword">new</span> Felix(configMap);
            <span class="code-comment">// Now start Felix instance.
</span>            m_felix.start();
        }
        <span class="code-keyword">catch</span> (Exception ex)
        {
            <span class="code-object">System</span>.err.println(<span class="code-quote">"Could not create framework: "</span> + ex);
            ex.printStackTrace();
        }

        m_tracker = <span class="code-keyword">new</span> ServiceTracker(
            m_activator.getContext(), Command.class.getName(), <span class="code-keyword">null</span>);
        m_tracker.open();
    }

    <span class="code-keyword">public</span> <span class="code-object">boolean</span> execute(<span class="code-object">String</span> name, <span class="code-object">String</span> commandline)
    {
        <span class="code-comment">// See <span class="code-keyword">if</span> any of the currently tracked command services
</span>        <span class="code-comment">// match the specified command name, <span class="code-keyword">if</span> so then execute it.
</span>        <span class="code-object">Object</span>[] services = m_tracker.getServices();
        <span class="code-keyword">for</span> (<span class="code-object">int</span> i = 0; (services != <span class="code-keyword">null</span>) &amp;&amp; (i &lt; services.length); i++)
        {
            <span class="code-keyword">try</span>
            {
                <span class="code-keyword">if</span> (((Command) services[i]).getName().equals(name))
                {
                    <span class="code-keyword">return</span> ((Command) services[i]).execute(commandline);
                }
            }
            <span class="code-keyword">catch</span> (Exception ex)
            {
                <span class="code-comment">// Since the services returned by the tracker could become
</span>                <span class="code-comment">// invalid at any moment, we will <span class="code-keyword">catch</span> all exceptions, log
</span>                <span class="code-comment">// a message, and then ignore faulty services.
</span>                <span class="code-object">System</span>.err.println(ex);
            }
        }
        <span class="code-keyword">return</span> <span class="code-keyword">false</span>;
    }

    <span class="code-keyword">public</span> void shutdownApplication()
    {
    {
        <span class="code-comment">// Shut down the felix framework when stopping the
</span>        <span class="code-comment">// host application.
</span>        m_felix.stop();
        m_felix.waitForStop();
    }
}</pre>
</div></div>

<p>The above example is overly simplistic with respect to concurrency
issues and error conditions, but it demonstrates the overall approach
for using bundle-provided services from the host application.</p>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-servicereflection"></a></p>

<h3><a name="ApacheFelixFrameworkLaunchingandEmbedding-UsingBundleServicesviaReflection"></a>Using Bundle Services via Reflection</h3>

<p>It possible for the host application to use services provided by
bundles without having access to the service interface classes and thus
not needing to put the service interface classes on the class path. To
do this, the host application uses the same general approach to acquire
the system bundle context object, which it can use to look up service
objects. Using either an LDAP filter or the service interface class
name, the host application can retrieve the service object and then use
standard Java reflection to invoke methods on the service object.</p>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-serviceother"></a></p>

<h3><a name="ApacheFelixFrameworkLaunchingandEmbedding-OtherApproaches"></a>Other Approaches</h3>

<p>The <span class="nobr"><a href="http://code.google.com/p/transloader/" title="Visit page outside Confluence" rel="nofollow">Transloader<sup><img class="rendericon" src="apache-felix-framework-launching-and-embedding_files/linkext7.gif" alt="" align="absmiddle" border="0" height="7" width="7"></sup></a></span> project is another attempt at dealing with issues of classes loaded from different class loaders and may be of interest.</p>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-caveat"></a></p>

<h1><a name="ApacheFelixFrameworkLaunchingandEmbedding-Caveat"></a>Caveat</h1>

<p>The code in this document has not been thoroughly tested nor even
compiled and may be out of date with respect to the current Felix
source code. If you find errors please report them so the that they can
be corrected.</p>

<p><a name="ApacheFelixFrameworkLaunchingandEmbedding-feedback"></a></p>

<h2><a name="ApacheFelixFrameworkLaunchingandEmbedding-Feedback"></a>Feedback</h2>

<p>Subscribe to the Felix users mailing list by sending a message to <span class="nobr"><a href="mailto:users-subscribe@felix.apache.org" title="Send mail to users-subscribe@felix.apache.org" rel="nofollow">users-subscribe@felix.apache.org<sup><img class="rendericon" src="apache-felix-framework-launching-and-embedding_files/mail_small.gif" alt="" align="absmiddle" border="0" height="12" width="13"></sup></a></span>; after subscribing, email questions or feedback to <span class="nobr"><a href="mailto:users@felix.apache.org" title="Send mail to users@felix.apache.org" rel="nofollow">users@felix.apache.org<sup><img class="rendericon" src="apache-felix-framework-launching-and-embedding_files/mail_small.gif" alt="" align="absmiddle" border="0" height="12" width="13"></sup></a></span>.</p>
    </div>
  </body></html>